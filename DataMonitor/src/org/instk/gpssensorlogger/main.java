package org.instk.gpssensorlogger;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.instk.gpssensorlogger.R;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
//import android.content.SharedPreferences;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.location.GpsStatus;
import android.location.GpsStatus.Listener;
import android.location.GpsSatellite;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Bundle;
import android.os.Environment;
import android.provider.Settings;
//import android.text.util.Linkify;
import android.view.View;
import android.view.View.OnClickListener;

import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;


public class main extends Activity implements OnClickListener, SensorEventListener, LocationListener, Listener {

	CSensorStates mSenStates;
	CLocProvStates mLPStates; //network (based on availability of cell tower and WiFi access points),
//	passive (This provider can be used to passively receive location updates when other applications or services request them without actually 
//	requesting the locations yourself. This provider will return locations generated by other providers),gps
	boolean mGPSState;
	CLogView mLV;
	int evno=0;

	SensorManager mSenMan;
	LocationManager mLocMan;

	Button mbtn_start,mbtn_stop;

	private BufferedWriter[] fout=new BufferedWriter[3];
//	private SimpleDateFormat dtf= new SimpleDateFormat("yyyyMMdd_HHmmss");
	private SimpleDateFormat day= new SimpleDateFormat("yyyyMMdd");
	private SimpleDateFormat dt= new SimpleDateFormat("dd.MM.yyyy HH:mm:ss");
	

	private void buildAlertMessageNoGps() {	//Alert Message in case GPS is disabled
		final AlertDialog.Builder builder = new AlertDialog.Builder(this);
		builder.setMessage("Your GPS seems to be disabled, do you want to enable it?")
		.setCancelable(false)
		.setPositiveButton("Yes", new DialogInterface.OnClickListener() {
			public void onClick(final DialogInterface dialog, final int id) {
				startActivity(new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS));
			}
		})
		.setNegativeButton("No", new DialogInterface.OnClickListener() {
			public void onClick(final DialogInterface dialog, final int id) {
				dialog.cancel();
			}
		});
		final AlertDialog alert = builder.create();
		alert.show();
	}


	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		SensorManager lSenMan=(SensorManager) getSystemService(SENSOR_SERVICE);
		LocationManager lLocMan=(LocationManager) getSystemService(Context.LOCATION_SERVICE);
		mSenMan=lSenMan;
		mLocMan=lLocMan;

		if ( !lLocMan.isProviderEnabled(LocationManager.GPS_PROVIDER) ) {	//alert message if GPS is diabled
			buildAlertMessageNoGps();
		}

		//Get the names of all sources
		mSenStates = new CSensorStates(lSenMan.getSensorList(Sensor.TYPE_ALL)); //nur noch Accelerometer
		mLPStates = new CLocProvStates(lLocMan.getAllProviders()); //ALLE Quellen
		mGPSState= false;

		//Construct the view
		setContentView(R.layout.main);
		mLV=(CLogView) findViewById(R.id.DLtv1);
		Button lbtn_start=(Button) findViewById(R.id.DLbtn0);
		Button lbtn_stop=(Button) findViewById(R.id.DLbtn2);
		Button lbtn_erec=(Button) findViewById(R.id.DLbtn3);
		Button lbtn_show=(Button) findViewById(R.id.DLbtn4);

		TextView ltv1 = (TextView) findViewById(R.id.Atv1);
//		ltv1.setText("This application was developed from the source codes available at github.com/yigiter/");
		ltv1.setText("Acceleration, GPS, Fastest delay"); //change comment here
//		Linkify.addLinks(ltv1, Linkify.ALL);

		lbtn_start.setOnClickListener(this);
		lbtn_stop.setOnClickListener(this);
		lbtn_erec.setOnClickListener(this);
		lbtn_show.setOnClickListener(this);

		lbtn_stop.setEnabled(false);
		mbtn_start=lbtn_start;
		mbtn_stop=lbtn_stop;		
		
		mLV.addtext("File Location:  " + file_location(null) + "\n");
	}

	@Override
	protected void onDestroy() { 
        mLV.addtext("Application killed.");
		super.onDestroy();
	}

	public void onClick(View arg0) {

		if (arg0.getId()==R.id.DLbtn0) { //Start Recording
			try {
				open_files();
				register_listeners();
				String ftag=dt.format(new Date());
				mLV.addtext("Started Logging: " + ftag);
			} catch (FileNotFoundException e) {
				mLV.addtext("File open error: Probably you do not have required permissions.");
				stop_recording();
			} catch (IOException e) {
				mLV.addtext("File open error: Probably you do not have required permissions.");
				stop_recording();
			}
		}
		else if (arg0.getId()==R.id.DLbtn2) { //Stop Recording
			stop_recording();
		}
		else if (arg0.getId()==R.id.DLbtn3) { //Save console to file
			dump_console();
			mLV.addtext("Logfile saved \n");
		}
		else if (arg0.getId()==R.id.DLbtn4) { //Show registered
			show_registered();
		}
	}

//	private void show_registered() {	//Show registered
//		CSensorStates lSenStates=mSenStates;
//		CLocProvStates lLPStates=mLPStates;
//
//		String nt="Registered Sources: \n";
//
//		int n=0;
//		for (int i=0;i<lSenStates.getNum();i++) {
//			if (lSenStates.getActive(i)) {
//				nt=nt+" " + lSenStates.getName(i);
//				n++;
//			}
//		}
//
//		for (int i=0;i<lLPStates.getNum();i++) {
//			if (lLPStates.getActive(i)) {
//				nt=nt+", " + lLPStates.getName(i);
//				n++;
//			}
//		}
//
//		if (mGPSState) {
//			nt=nt+", GPS Status";
//			n++;
//		}
//
//		if (n==0) {
//			nt="No Registered Source.";
//		}
//
//		mLV.addtext(nt + "\n");
//	}

	private void show_registered() {	//Show registered
		CSensorStates lSenStates=mSenStates;
		CLocProvStates lLPStates=mLPStates;

		String nt="REGISTERED SOURCES: \n";
		nt=nt + "SENSORS: Total Number: " + mSenStates.getNum() + " Active:" + mSenStates.getNumAct() + "\n";
		int n=0;
		for (int i=0;i<lSenStates.getNum();i++) {
			if (lSenStates.getActive(i)) 
				nt=nt + lSenStates.getName(i) + " (active)\n";
			else
				nt=nt + lSenStates.getName(i) + " (inactive) \n";
			n++;
		}
		nt=nt + "PROVIDERS: Total Number: " + mLPStates.getNum() + " Active:" + mLPStates.getNumAct() + "\n";
		for (int i=0;i<lLPStates.getNum();i++) {
			if (lLPStates.getActive(i)) 
				nt=nt + lLPStates.getName(i) + " (active) \n";
			else
				nt=nt + lLPStates.getName(i) + " (inactive) \n";
			n++;			
		}

		if (mGPSState) {
			nt=nt+", GPS Status";
			n++;
		}

		if (n==0) {
			nt="No Registered Source.";
		}

		mLV.addtext(nt + "\n");
	}
	
	private void close_files() {	//close files
		BufferedWriter[] bfout=fout;
		for (int i=0;i<3;i++) {
			if (bfout[i]!=null)
				try {
					bfout[i].close();
				} catch (IOException e) {
					mLV.addtext("File close error :" + i);
				}
		}		
		for (int i=0;i<3;i++) {
			if (bfout[i]!=null)
				try {
					bfout[i].close();
				} catch (IOException e) {
					mLV.addtext("File close error :" + i);
				}
		}
	}

	private void open_files() throws IOException, FileNotFoundException {	//open files

		//Adjust view
		mbtn_start.setEnabled(false);
		mbtn_stop.setEnabled(true);

		//Refs
		CSensorStates lSenStates=mSenStates;
		CLocProvStates lLPStates=mLPStates;
		BufferedWriter[] bfout=fout;
		String start_text=null;

		//Open the files and register the listeners
		if (lSenStates.getNumAct()>0) {
			if (file_location("accelerometer_").exists())
				start_text = "";
			else
				start_text = "% ACCELEROMETER\n\n% Attributes:\n% system time, time stamp, sensor type, x_value, y_value, z_value \n\nacc = [";
			bfout[0]=new BufferedWriter(new FileWriter(file_location("accelerometer_"), true));

			BufferedWriter file=fout[0];
			if (file!=null) {
				try {
					file.append(start_text);
//					file.append("SENSORS\n\nAttributes:\nsystem time, sensor name, time stamp, no of values, values \n\n");
				} catch (IOException e) {
					mLV.addtext("Error: Could not write to file!");
				}
			}
		}
		else
			bfout[0]=null;

		if (lLPStates.getNumAct()>0) {
			
			if (file_location("locprovider_").exists())
				start_text = "";
			else
				start_text = "% NETWORK PROVIDER\n\n% Attributes:\n% system time, provider name (3 for gps, 7 for network), pr. time, pr. accuracy, " +
							"pr. latitude, pr. longitude, pr. bearing, pr. speed \n\n" +
							"provider = [";
			
			bfout[1]=new BufferedWriter(new FileWriter(file_location("locprovider_"), true));
			BufferedWriter file=fout[1];

			if (file!=null) {
				try {
					file.append(start_text);
				} catch (IOException e) {
					mLV.addtext("Error: Could not write to file!");
				}
			}			
		}
		else
			bfout[1]=null;

		if (mGPSState) {
			
			if (file_location("gpsstate_").exists())
				start_text = "";
			else
				start_text = "% GPS STATUS\n\n% Attributes:\n% system time, PRN, Azimuth, Elevation, SNR, Almanach, " +
						"Ephemeris, Sat. used in last fix, if next: @, if no next: # \n\n" +
						"gps_status = [";
			
			bfout[2]=new BufferedWriter(new FileWriter(file_location("gpsstate_"), true));
			BufferedWriter file=fout[2];

			if (file!=null) {
				try {
					file.append(start_text);						
				} catch (IOException e) {
					mLV.addtext("Error: Could not write to file!");
				}
			}
		}
		else
			bfout[2]=null;
	}

	private File file_location(String ntag) {

		String state = Environment.getExternalStorageState();

		if (Environment.MEDIA_MOUNTED.equals(state)) {
			// We can read and write the media
			String ftag=day.format(new Date()); // Nur Tag als Dateiname
			File root = new File(Environment.getExternalStorageDirectory(), "GPSSensorLogger/v1.0"); //speichert in sdcard/GPSSensorLogger
			if (!root.exists()) {
				root.mkdirs();
			}

			if (ntag == null) {
				return root;
			} else
				return new File(root, ntag+ftag+".m");
			//  return new File(getExternalFilesDir(null), ntag + ftag + ".m");		Speichert in android/data/files/org.instk.gpssensorlogger  

		} else {
			// We can not read and write the media
			mLV.addtext("No external Storage.");
			return null;
		}
	}

	private void register_listeners() {

		CSensorStates lSenStates=mSenStates;
		CLocProvStates lLPStates=mLPStates;
		SensorManager lSenMan=mSenMan;
		LocationManager lLocMan=mLocMan;		
		BufferedWriter[] bfout=fout;


		//Register the sensors
		if (bfout[0]!=null) {
			for (int i=0;i<lSenStates.getNum();i++) {
				if (lSenStates.getActive(i))
					lSenMan.registerListener(this, lSenMan.getDefaultSensor(lSenStates.getType(i)), SensorManager.SENSOR_DELAY_FASTEST);	//change delay here		
			}
		}


		//Register listeners for active location providers
		if (bfout[1]!=null) {	
			for (int i=0;i<lLPStates.getNum();i++) {
				if (lLPStates.getActive(i))
					lLocMan.requestLocationUpdates(lLPStates.getName(i), 0, 0, this); //mintime, mindist
			}
		}

		if (bfout[2]!=null) {
			lLocMan.addGpsStatusListener(this);
		}
	}

	private void stop_recording() {
		//Stop Recording
		mSenMan.unregisterListener(this);
		mLocMan.removeGpsStatusListener(this);
		mLocMan.removeUpdates(this);

		//Dialog Window to add comments
		AlertDialog.Builder alert = new AlertDialog.Builder(this);
		
		alert.setTitle("Any comments?");
		alert.setMessage("Please comment on transport mode and route:");
		
		// Set an EditText view to get user input 
		final EditText input = new EditText(this);
		alert.setView(input);
		
		alert.setPositiveButton("Ok", new DialogInterface.OnClickListener() {
			public void onClick(DialogInterface dialog, int whichButton) {
				String comment = input.getText().toString();
			
				BufferedWriter file0=fout[0], file1 = fout[1], file2 = fout[2];
				String daytime=dt.format(new Date());

				try {
					if (file0!=null)
						file0.append("\n\n% COMMENT ( " + daytime + " ): \n% " + comment + " (fastest,acc,gps)\n"); //change comment here
					if (file1!=null)
						file1.append("\n\n% COMMENT ( " + daytime + " ): \n% " + comment + " (fastest,acc,gps)\n"); //change comment here
					if (file2!=null)
						file2.append("\n\n% COMMENT ( " + daytime + " ): \n% " + comment + " (fastest,acc,gps)\n"); //change comment here
					mLV.addtext("Saved comment.");
					close_files();					
					mLV.addtext("Stopped Logging: " + daytime + "\n");
				} catch (IOException e) {
					mLV.addtext("Error: Could not write to file!");
					close_files();
					mLV.addtext("Stopped Logging: " + daytime + "\n");
				}
			}
		});
		
		alert.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
			public void onClick(DialogInterface dialog, int whichButton) {
				BufferedWriter file0=fout[0], file1 = fout[1], file2 = fout[2];
				String daytime=dt.format(new Date());

				try {
					if (file0!=null)
					file0.append("\n\n% NO COMMENT ( " + daytime + ",  fastest,acc,gps)"); //change comment here
					if (file1!=null)
						file1.append("\n\n% NO COMMENT ( " + daytime + ",  fastest,acc,gps)"); //change comment here
					if (file2!=null)
						file2.append("\n\n% NO COMMENT ( " + daytime + ",  fastest,acc,gps)"); //change comment here
					close_files();		
					mLV.addtext("Stopped Logging: " + daytime + "\n");
				} catch (IOException e) {
					mLV.addtext("Error: Could not write to file!");
					close_files();
					mLV.addtext("Stopped Logging: " + daytime + "\n");
				}
				// Canceled.
			}
		});
		alert.show();
		
		
		//Adjust view
		mbtn_start.setEnabled(true);
		mbtn_stop.setEnabled(false);
	}

	private void dump_console() {
		try {
			String daytime=dt.format(new Date());
			BufferedWriter file = new BufferedWriter(new FileWriter(file_location("log_"), true));
			file.append("LOGFILE ( " + daytime + ")\n" + mLV.getText().toString() + "\n\n");
			file.close();
		}
		catch (FileNotFoundException e) {
			mLV.addtext("Error: Could not open file for writing");
		}
		catch (IOException e1) {
			mLV.addtext("Error: Could not save file!");
		}
	}

	///////////Sensor Listener Callbacks
	public void onAccuracyChanged(Sensor sensor, int accuracy) {
		// Do nothing		
	}
	
	public void onSensorChanged(SensorEvent ev) {
		BufferedWriter file=fout[0];
		
		if (file==null) //Something is wrong
			return;

		long tim=System.currentTimeMillis();
//		int len=ev.values.length;
		
//		if (Math.abs(ev.values[1]+ev.values[2]+ev.values[3]) > 0.05){
			try {
				file.append("\n" + String.valueOf(tim));
				file.append(", " + String.valueOf(ev.timestamp));
				file.append(", " + String.valueOf(ev.sensor.getType()));
				for (int i=0;i<3;i++) //eigentlich len
					file.append(", " + (String.valueOf(ev.values[i])));
				file.append(";");
			} catch (IOException e) {
				mLV.addtext("Error: Could not write to file!");
			}
//		}

	}

	/////////Location provider callbacks
	public void onLocationChanged(Location loc) {
		BufferedWriter file=fout[1];

		if (file==null)
			//Something is wrong
			return;
		long tim=System.currentTimeMillis();
		try {
			file.append("\n" + String.valueOf(tim)); //Returns the current system time in milliseconds since January 1, 1970 00:00:00 UTC. This method shouldn't be used for measuring timeouts or other elapsed time measurements, as changing the system time can affect the results.
			file.append(", " + String.valueOf(loc.getProvider().length())); //Returns the name of the provider that generated this fix, or null if it is not associated with a provider
			file.append(", " + String.valueOf(loc.getTime())); //Returns the UTC time of this fix, in milliseconds since January 1, 1970.
			file.append(", " + String.valueOf(loc.getAccuracy())); //Returns the accuracy of the fix in meters. If hasAccuracy() is false, 0.0 is returned
			file.append(", " + String.valueOf(loc.getLatitude()));
			file.append(", " + String.valueOf(loc.getLongitude()));
			file.append(", " + String.valueOf(loc.getBearing())); //Returns the direction of travel in degrees East of true North. If hasBearing() is false, 0.0 is returned
			file.append(", " + String.valueOf(loc.getSpeed())); //Returns the speed of the device over ground in meters/second. If hasSpeed() is false, 0.0 is returned
			file.append(";");
		} catch (IOException e) {
			mLV.addtext("Error: Could not write to file!");
		}
	}

	public void onProviderDisabled(String arg0) {
		mLV.addtext(arg0 + " provider disabled");
	}

	public void onProviderEnabled(String arg0) {
		mLV.addtext(arg0 + " provider enabled");
	}

	public void onStatusChanged(String arg0, int arg1, Bundle arg2) {
//		mLV.addtext(arg0 + " status changed :" + arg1);
	}

	///////GPS status callback
	public void onGpsStatusChanged(int status) {
		BufferedWriter file=fout[2];

		long tim=System.currentTimeMillis();

		//Get the status
		GpsStatus lStatus=null;
		lStatus=mLocMan.getGpsStatus(null);

		if (lStatus!=null) {
			if (file!=null) {
				try {
					file.append("\n" + String.valueOf(tim)); //System time
					Iterable<GpsSatellite> satlist=lStatus.getSatellites(); //Returns an array of GpsSatellite objects, which represent the current state of the GPS engine
					for (GpsSatellite sat:satlist) {

						file.append(", " + String.valueOf(sat.getPrn())); //Returns the PRN (pseudo-random number) for the satellite.
						file.append(", " + String.valueOf(sat.getAzimuth())); //Returns the azimuth of the satellite in degrees. The azimuth can vary between 0 and 360
						file.append(", " + String.valueOf(sat.getElevation())); //Returns the elevation of the satellite in degrees. The elevation can vary between 0 and 90.
						file.append(", " + String.valueOf(sat.getSnr())); //Returns the signal to noise ratio for the satellite
//		naN				file.append(", " + String.valueOf(sat.hasAlmanac())); //Returns true if the GPS engine has almanac data for the satellite
//		naN				file.append(", " + String.valueOf(sat.hasEphemeris())); //Returns true if the GPS engine has ephemeris data for the satellite
//		naN				file.append(", " + String.valueOf(sat.usedInFix())); //Returns true if the satellite was used by the GPS engine when calculating the most recent GPS fix.

//		naN				if (satlist.iterator().hasNext()) //Returns true if there is at least one more element, false otherwise
//		naN					file.append('@');
//		naN				else
//		naN					file.append('#');
						file.append(";");
					}
				} catch (IOException e) {
					mLV.addtext("Error: Could not write to file!");
				}
			}
		}
	}
}
